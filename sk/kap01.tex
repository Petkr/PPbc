\chapter{Definície}

Na začiatok uvedieme definície pojmov, ktoré sú pre túto prácu bazálne.
\emph{Reflexia} je schopnosť programu manipulovať s reprezentáciami stavu daného programu ako s dátami.
Jeden z aspektov reflexie je \emph{introspekcia}, čo je schopnosť programu pozorovať svoj vlastný stav.

\chapter{Význam reflexie a introspekcie}



\chapter{Introspekcia v C++}

C++ ponúka introspekciu v dvoch podobách.

Do prvej spadajú operátory \texttt{sizeof}, \texttt{sizeof...} a \texttt{alignof}. Napríklad, \texttt{sizeof} akceptuje ako argument typ alebo výraz a vracia veľkosť daného typu, respektíve veľkosť typu daného výrazu. Ak je argument výraz, zvažuje sa jeho \emph{statický typ}, nie \emph{dynamický typ}. Statický typ je typ plynúci z deklarácie v zdrojovom texte, napríklad pri výraze volania funkcie je to návratový typ funkcie. Dynamický typ výrazu je typ najviac odvodeného objektu, na ktorý výraz odkazuje.
%$
\begin{code}
struct Base {};
struct Derived : Base {};

Base b;
Derived d;

Base& x = b;
Base& y = d;

x; // static type: Base, dynamic type: Base
y; // static type: Base, dynamic type: Derived
\end{code}
%$
\texttt{sizeof} svoj argument nevyhodnocuje - entita, ktorú skúma, je entita zdrojového textu, nie hodnota v pamäti. Ostatné dva operátory fungujú obdobne: nezvažujú stav programu počas behu, ale informácia, ktorú ponúkajú, plynie iba z formy zdrojového textu. Táto podoba introspekcie pozoruje vlastnosti programu v kompilačnom čase, nazveme ju teda \emph{kompilačná introspekcia}.

Druhá podoba introspekcie v C++ je založená na operátore \texttt{typeid}. Ten akceptuje typ alebo výraz a vracia odkaz na \texttt{std::type\_info}, ktorý reprezentuje typ, respektíve typ výrazu. \texttt{std::type\_info} má definované úplné usporiadanie a dokáže získať meno reprezentovaného typu. Rozdiel oproti kompilačnej introspekcii je tu v tom, že \texttt{typeid} svoj argument vyhodnocuje, pretože ako typ výrazu rozumie jeho dynamický typ. Ten je známy až za behu z hodnoty výrazu. Táto introspekcia pozoruje program za behu, nazveme ju \emph{behová introspekcia}.

Tento pohľad na druhy introspekcie v C++ ukazuje istú medzeru v ponúkaných nástrojoch štandardným C++. Ak máme spôsob, ako z typu určiť jeho veľkosť, a tiež máme nástroj, ako z hodnoty určiť jej \uv{behový} typ, prečo nemožno jednoducho určiť z hodnoty veľkosť jej behového typu? To by vyžadovalo mapovanie medzi reprezentantmi typov a informáciami o typoch. K tomuto problému sa vrátime pri implementácii.

V tejto kapitole sú zámerne vynechané detaily, ktoré nie sú podstatné pre účel tejto časti. Špeciálne: dynamický typ má zmysel iba pre výrazy kategórie glvalue, prvalue sa v \texttt{typeid} nevyhodnocuje a  \texttt{typeid} rozlišuje iba dynamický typ výrazov polymorfných typov. Všetky tieto nepresnosti budú v práci vyjasnené, keď budú mať nejaký dopad.
